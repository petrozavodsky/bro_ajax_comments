/**
 * Plugin developed to save html forms data to LocalStorage to restore them after browser crashes, tabs closings
 * and other disasters. 
 * 
 * https://github.com/simsalabim/sisyphus
 *
 * @author Alexander Kaupanin <kaupanin@gmail.com>
 * @license MIT - see https://github.com/simsalabim/sisyphus/blob/master/MIT-LICENSE
 */
!function(t){function e(t){return"[id="+t.attr("id")+"][name="+t.attr("name")+"]"}t.fn.sisyphus=function(i){var n=t.map(this,function(i){return e(t(i))}).join(),o=Sisyphus.getInstance(n);return o.protect(this,i),o};var i={};/**
	 * Check if local storage or other browser storage is available
	 *
	 * @return Boolean
	 */
i.isAvailable=function(){if("object"==typeof t.jStorage)return!0;try{return localStorage.getItem}catch(t){return!1}},/**
	 * Set data to browser storage
	 *
	 * @param [String] key
	 * @param [String] value
	 *
	 * @return Boolean
	 */
i.set=function(e,i){if("object"==typeof t.jStorage)t.jStorage.set(e,i+"");else try{localStorage.setItem(e,i+"")}catch(t){}},/**
	 * Get data from browser storage by specified key
	 *
	 * @param [String] key
	 *
	 * @return string
	 */
i.get=function(e){if("object"==typeof t.jStorage){var i=t.jStorage.get(e);return i?i.toString():i}return localStorage.getItem(e)},/**
	 * Delete data from browser storage by specified key
	 *
	 * @param [String] key
	 *
	 * @return void
	 */
i.remove=function(e){"object"==typeof t.jStorage?t.jStorage.deleteKey(e):localStorage.removeItem(e)},Sisyphus=function(){function n(){return{setInstanceIdentifier:function(t){this.identifier=t},getInstanceIdentifier:function(){return this.identifier},/**
				 * Set plugin initial options
				 *
				 * @param [Object] options
				 *
				 * @return void
				 */
setInitialOptions:function(e){var n={excludeFields:[],customKeySuffix:"",locationBased:!1,timeout:0,autoRelease:!0,onBeforeSave:function(){},onSave:function(){},onBeforeRestore:function(){},onRestore:function(){},onRelease:function(){}};this.options=this.options||t.extend(n,e),this.browserStorage=i},/**
				 * Set plugin options
				 *
				 * @param [Object] options
				 *
				 * @return void
				 */
setOptions:function(e){this.options=this.options||this.setInitialOptions(e),this.options=t.extend(this.options,e)},/**
				 * Protect specified forms, store it's fields data to local storage and restore them on page load
				 *
				 * @param [Object] targets		forms object(s), result of jQuery selector
				 * @param Object options			plugin options
				 *
				 * @return void
				 */
protect:function(e,i){this.setOptions(i),e=e||{};var n=this;if(this.targets=this.targets||[],n.options.name?this.href=n.options.name:this.href=location.hostname+location.pathname+location.search+location.hash,this.targets=t.merge(this.targets,e),this.targets=t.unique(this.targets),this.targets=t(this.targets),!this.browserStorage.isAvailable())return!1;var s=n.options.onBeforeRestore.call(n);if((void 0===s||s)&&n.restoreAllData(),this.options.autoRelease&&n.bindReleaseData(),!o.started[this.getInstanceIdentifier()])if(n.isCKEditorPresent())var r=setInterval(function(){a.isLoaded&&(clearInterval(r),n.bindSaveData(),o.started[n.getInstanceIdentifier()]=!0)},100);else n.bindSaveData(),o.started[n.getInstanceIdentifier()]=!0},isCKEditorPresent:function(){return!!this.isCKEditorExists()&&(a.isLoaded=!1,a.on("instanceReady",function(){a.isLoaded=!0}),!0)},isCKEditorExists:function(){return"undefined"!=typeof a},findFieldsToProtect:function(t){return t.find(":input").not(":submit").not(":reset").not(":button").not(":file").not(":password").not(":disabled").not("[readonly]")},/**
				 * Bind saving data
				 *
				 * @return void
				 */
bindSaveData:function(){var i=this;i.options.timeout&&i.saveDataByTimeout(),i.targets.each(function(){var n=e(t(this));i.findFieldsToProtect(t(this)).each(function(){if(t.inArray(this,i.options.excludeFields)!==-1)
// Returning non-false is the same as a continue statement in a for loop; it will skip immediately to the next iteration.
return!0;var o=t(this),a=(i.options.locationBased?i.href:"")+n+e(o)+i.options.customKeySuffix;(o.is(":text")||o.is("textarea"))&&(i.options.timeout||i.bindSaveDataImmediately(o,a)),i.bindSaveDataOnChange(o)})})},/**
				 * Save all protected forms data to Local Storage.
				 * Common method, necessary to not lead astray user firing 'data is saved' when select/checkbox/radio
				 * is changed and saved, while text field data is saved only by timeout
				 *
				 * @return void
				 */
saveAllData:function(){var i=this;i.targets.each(function(){var n=e(t(this)),o={};i.findFieldsToProtect(t(this)).each(function(){var s=t(this);if(t.inArray(this,i.options.excludeFields)!==-1||void 0===s.attr("name")&&void 0===s.attr("id"))
// Returning non-false is the same as a continue statement in a for loop; it will skip immediately to the next iteration.
return!0;var r=(i.options.locationBased?i.href:"")+n+e(s)+i.options.customKeySuffix,c=s.val();if(s.is(":checkbox")){var u=s.attr("name");if(void 0!==u&&u.indexOf("[")!==-1){if(o[u]===!0)return;c=[],t("[name='"+u+"']:checked").each(function(){c.push(t(this).val())}),o[u]=!0}else c=s.is(":checked");i.saveToBrowserStorage(r,c,!1)}else if(s.is(":radio"))s.is(":checked")&&(c=s.val(),i.saveToBrowserStorage(r,c,!1));else if(i.isCKEditorExists()){var f=a.instances[s.attr("name")]||a.instances[s.attr("id")];f?(f.updateElement(),i.saveToBrowserStorage(r,s.val(),!1)):i.saveToBrowserStorage(r,c,!1)}else i.saveToBrowserStorage(r,c,!1)})}),i.options.onSave.call(i)},/**
				 * Restore forms data from Local Storage
				 *
				 * @return void
				 */
restoreAllData:function(){var i=this,n=!1;i.targets.each(function(){var o=t(this),a=e(t(this));i.findFieldsToProtect(o).each(function(){if(t.inArray(this,i.options.excludeFields)!==-1)
// Returning non-false is the same as a continue statement in a for loop; it will skip immediately to the next iteration.
return!0;var o=t(this),s=(i.options.locationBased?i.href:"")+a+e(o)+i.options.customKeySuffix,r=i.browserStorage.get(s);null!==r&&(i.restoreFieldsData(o,r),n=!0)})}),n&&i.options.onRestore.call(i)},/**
				 * Restore form field data from local storage
				 *
				 * @param Object field		jQuery form element object
				 * @param String resque	 previously stored fields data
				 *
				 * @return void
				 */
restoreFieldsData:function(t,e){if(void 0===t.attr("name")&&void 0===t.attr("id"))return!1;var i=t.attr("name");!t.is(":checkbox")||"false"===e||void 0!==i&&i.indexOf("[")!==-1?!t.is(":checkbox")||"false"!==e||void 0!==i&&i.indexOf("[")!==-1?t.is(":radio")?t.val()===e&&t.prop("checked",!0):void 0===i||i.indexOf("[")===-1?
// If we aren't named by name (e.g. id) or we aren't in a multiple element field
t.val(e):(e=e.split(","),t.val(e)):
// If we aren't named by name (e.g. id) or we aren't in a multiple element field
t.prop("checked",!1):
// If we aren't named by name (e.g. id) or we aren't in a multiple element field
t.prop("checked",!0)},/**
				 * Bind immediate saving (on typing/checking/changing) field data to local storage when user fills it
				 *
				 * @param Object field		jQuery form element object
				 * @param String prefix	 prefix used as key to store data in local storage
				 *
				 * @return void
				 */
bindSaveDataImmediately:function(t,e){var i=this;if("onpropertychange"in t?t.get(0).onpropertychange=function(){i.saveToBrowserStorage(e,t.val())}:t.get(0).oninput=function(){i.saveToBrowserStorage(e,t.val())},this.isCKEditorExists()){var n=a.instances[t.attr("name")]||a.instances[t.attr("id")];n&&n.document.on("keyup",function(){n.updateElement(),i.saveToBrowserStorage(e,t.val())})}},/**
				 * Save data to Local Storage and fire callback if defined
				 *
				 * @param String key
				 * @param String value
				 * @param Boolean [true] fireCallback
				 *
				 * @return void
				 */
saveToBrowserStorage:function(t,e,i){var n=this,o=n.options.onBeforeSave.call(n);void 0!==o&&o===!1||(
// if fireCallback is undefined it should be true
i=void 0===i||i,this.browserStorage.set(t,e),i&&""!==e&&this.options.onSave.call(this))},/**
				 * Bind saving field data on change
				 *
				 * @param Object field		jQuery form element object
				 *
				 * @return void
				 */
bindSaveDataOnChange:function(t){var e=this;t.change(function(){e.saveAllData()})},/**
				 * Saving (by timeout) field data to local storage when user fills it
				 *
				 * @return void
				 */
saveDataByTimeout:function(){var t=this,e=t.targets;setTimeout(function(){function e(){t.saveAllData(),setTimeout(e,1e3*t.options.timeout)}return e}(e),1e3*t.options.timeout)},/**
				 * Bind release form fields data from local storage on submit/reset form
				 *
				 * @return void
				 */
bindReleaseData:function(){var i=this;i.targets.each(function(){var n=t(this),o=e(n);t(this).bind("submit reset",function(){i.releaseData(o,i.findFieldsToProtect(n))})})},/**
				 * Manually release form fields
				 *
				 * @return void
				 */
manuallyReleaseData:function(){var i=this;i.targets.each(function(){var n=t(this),o=e(n);i.releaseData(o,i.findFieldsToProtect(n))})},/**
				 * Bind release form fields data from local storage on submit/resett form
				 *
				 * @param String targetFormIdAndName	a form identifier consists of its id and name glued
				 * @param Object fieldsToProtect		jQuery object contains form fields to protect
				 *
				 * @return void
				 */
releaseData:function(i,n){var a=!1,s=this;
// Released form, are not started anymore. Fix for ajax loaded forms.
o.started[s.getInstanceIdentifier()]=!1,n.each(function(){if(t.inArray(this,s.options.excludeFields)!==-1)
// Returning non-false is the same as a continue statement in a for loop; it will skip immediately to the next iteration.
return!0;var n=t(this),o=(s.options.locationBased?s.href:"")+i+e(n)+s.options.customKeySuffix;s.browserStorage.remove(o),a=!0}),a&&s.options.onRelease.call(s)}}}var o={instantiated:[],started:[]},a=window.CKEDITOR;return{getInstance:function(t){return o.instantiated[t]||(o.instantiated[t]=n(),o.instantiated[t].setInstanceIdentifier(t),o.instantiated[t].setInitialOptions()),t?o.instantiated[t]:o.instantiated[t]},free:function(){return o={instantiated:[],started:[]},null},version:"1.1.2"}}()}(jQuery);